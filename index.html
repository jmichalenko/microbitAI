<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Teachable Machine → micro:bit USB Serial Bridge</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 18px; line-height: 1.35; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin: 10px 0; }
    input[type="text"] { width: min(900px, 100%); padding: 10px; font-size: 14px; }
    button { padding: 10px 14px; font-size: 14px; cursor: pointer; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; margin-top: 12px; }
    .small { font-size: 12px; color: #444; }
    .status { font-weight: 600; }
    .good { color: #0a7a0a; }
    .bad { color: #b00020; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-wrap; }
    #webcam { width: 320px; height: 240px; background: #000; border-radius: 10px; }
    label { font-weight: 600; }
  </style>

  <!-- TFJS + Teachable Machine Image library -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8/dist/teachablemachine-image.min.js"></script>
</head>

<body>
  <h1>Teachable Machine → micro:bit USB Serial Bridge</h1>

  <div class="card">
    <p class="small">
      Important: This page must be opened from <span class="mono">http://localhost</span> (or https), not as a local file.
      See the “How students open it” section below.
    </p>

    <div class="row">
      <label for="modelUrl">Teachable Machine model URL (folder that contains model.json):</label>
    </div>
    <div class="row">
      <input id="modelUrl" type="text"
        placeholder="Example: https://teachablemachine.withgoogle.com/models/XXXX/  (or your hosted export folder)"
        autocomplete="off" />
      <button id="btnCheck">Check URL</button>
    </div>

    <div class="row">
      <button id="btnConnect">Connect micro:bit (USB)</button>
      <button id="btnStart" disabled>Start</button>
      <button id="btnStop" disabled>Stop</button>
    </div>

    <div class="row">
      <label for="threshold">Confidence threshold:</label>
      <input id="threshold" type="range" min="0.50" max="0.99" step="0.01" value="0.85" />
      <span class="mono" id="thresholdVal">0.85</span>
      <label for="minInterval" style="margin-left:14px;">Min send interval (ms):</label>
      <input id="minInterval" type="number" value="350" min="50" max="5000" step="50" style="width:110px;padding:8px;" />
    </div>

    <p class="status" id="status">Status: <span class="bad">Not connected</span></p>
    <p class="small">What gets sent to the micro:bit: <span class="mono">TOP_CLASS_NAME\n</span></p>
  </div>

  <div class="row">
    <canvas id="webcam" width="320" height="240"></canvas>

    <div class="card" style="flex:1; min-width: 320px;">
      <h3>Live prediction</h3>
      <div class="mono" id="predOut">—</div>
      <h3>Serial log</h3>
      <div class="mono" id="log" style="max-height:240px; overflow:auto;">—</div>
    </div>
  </div>

  <div class="card">
    <h2>How students open it (the reliable way)</h2>
    <ol>
      <li>Put <span class="mono">tm-microbit-bridge.html</span> in a folder (e.g., Desktop → Bridge).</li>
      <li>Open a terminal/command prompt <strong>in that folder</strong>.</li>
      <li>Run ONE of these:</li>
    </ol>

    <p class="mono">
Windows (Python installed):  py -m http.server 8000
macOS/Linux:                python3 -m http.server 8000
    </p>

    <ol start="4">
      <li>Open Chrome and go to: <span class="mono">http://localhost:8000/tm-microbit-bridge.html</span></li>
      <li>Paste the model URL, click <strong>Check URL</strong>, connect the micro:bit, then click <strong>Start</strong>.</li>
    </ol>

    <p class="small">
      If “Check URL” fails with 404 on <span class="mono">model.json</span>, students likely pasted a “share page” URL that does not expose the model files.
      In that case: Teachable Machine → Export Model → TensorFlow.js → host the exported folder (even locally) and paste that folder URL.
    </p>
  </div>

<script>
  // ---------- UI helpers ----------
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  function log(msg) {
    const now = new Date().toLocaleTimeString();
    logEl.textContent = (logEl.textContent === "—" ? "" : logEl.textContent) + `[${now}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function setStatus(text, ok) {
    $("status").innerHTML = `Status: <span class="${ok ? "good" : "bad"}">${text}</span>`;
  }

  // ---------- Web Serial ----------
  let port = null;
  let writer = null;

  async function connectSerial() {
    if (!("serial" in navigator)) {
      alert("Web Serial not supported. Use Chrome or Edge on desktop.");
      return;
    }
    port = await navigator.serial.requestPort();
    await port.open({ baudRate: 115200 });
    writer = port.writable.getWriter();
    setStatus("micro:bit connected (USB serial)", true);
    log("Connected to micro:bit.");
  }

  async function sendLine(line) {
    if (!writer) return;
    const data = new TextEncoder().encode(line + "\n");
    await writer.write(data);
  }

  async function disconnectSerial() {
    try {
      if (writer) { writer.releaseLock(); writer = null; }
      if (port) { await port.close(); port = null; }
    } catch (e) {
      // ignore
    }
    setStatus("Not connected", false);
    log("Disconnected.");
  }

  // ---------- Teachable Machine (Image) ----------
  let model = null;
  let webcam = null;
  let loopHandle = null;

  let lastSentLabel = "";
  let lastSentTime = 0;

  function normalizeBaseUrl(u) {
    // Accept either:
    //  - https://.../models/XXXX/
    //  - https://.../models/XXXX   (we add /)
    //  - a hosted folder URL (we add /)
    u = (u || "").trim();
    if (!u) return "";
    if (!u.endsWith("/")) u += "/";
    return u;
  }

  async function checkModelUrl(baseUrl) {
    const modelJson = baseUrl + "model.json";
    const res = await fetch(modelJson, { method: "GET" });
    return res.ok;
  }

  async function loadModel(baseUrl) {
    const modelURL = baseUrl + "model.json";
    const metadataURL = baseUrl + "metadata.json";
    model = await tmImage.load(modelURL, metadataURL);
    log("Model loaded.");

    // Setup webcam
    const flip = true;
    webcam = new tmImage.Webcam(320, 240, flip);
    await webcam.setup();
    await webcam.play();
    log("Webcam started.");

    // Draw into our canvas
    const canvas = $("webcam");
    const ctx = canvas.getContext("2d");

    async function frame() {
      webcam.update();
      ctx.drawImage(webcam.canvas, 0, 0, canvas.width, canvas.height);
      await predictAndMaybeSend();
      loopHandle = requestAnimationFrame(frame);
    }

    loopHandle = requestAnimationFrame(frame);
  }

  async function stopAll() {
    if (loopHandle) cancelAnimationFrame(loopHandle);
    loopHandle = null;

    if (webcam) {
      try { await webcam.stop(); } catch(e) {}
      webcam = null;
    }
    model = null;
    $("predOut").textContent = "—";
    log("Stopped.");
  }

  async function predictAndMaybeSend() {
    if (!model || !webcam) return;

    const preds = await model.predict(webcam.canvas);
    // find best
    let best = preds[0];
    for (const p of preds) if (p.probability > best.probability) best = p;

    const thr = parseFloat($("threshold").value);
    const minMs = parseInt($("minInterval").value || "350", 10);
    const now = Date.now();

    $("predOut").textContent =
      `Top: ${best.className}  (${best.probability.toFixed(3)})\n` +
      preds.map(p => `${p.className}: ${p.probability.toFixed(3)}`).join("\n");

    // Only send if:
    // - connected
    // - above threshold
    // - changed label OR enough time passed
    if (writer && best.probability >= thr) {
      const changed = best.className !== lastSentLabel;
      const timed = (now - lastSentTime) >= minMs;

      if (changed || timed) {
        lastSentLabel = best.className;
        lastSentTime = now;
        await sendLine(best.className);
        log(`Sent → ${best.className}`);
      }
    }
  }

  // ---------- Wire UI ----------
  $("threshold").addEventListener("input", () => {
    $("thresholdVal").textContent = $("threshold").value;
  });

  $("btnConnect").addEventListener("click", async () => {
    try {
      await connectSerial();
    } catch (e) {
      alert("Could not connect to micro:bit.\n\n" + e.message);
      log("Connect error: " + e.message);
      setStatus("Not connected", false);
    }
  });

  $("btnCheck").addEventListener("click", async () => {
    const base = normalizeBaseUrl($("modelUrl").value);
    if (!base) return alert("Paste a model URL first.");
    try {
      log("Checking: " + base + "model.json");
      const ok = await checkModelUrl(base);
      if (ok) {
        alert("Looks good: model.json was found.");
        log("Model URL OK.");
        $("btnStart").disabled = false;
      } else {
        alert("Could not find model.json at that URL.\n\nTip: Export the model as TensorFlow.js and host the exported folder, then paste that folder URL.");
        log("Model URL failed (model.json not found).");
        $("btnStart").disabled = true;
      }
    } catch (e) {
      alert("URL check failed:\n\n" + e.message);
      log("URL check error: " + e.message);
      $("btnStart").disabled = true;
    }
  });

  $("btnStart").addEventListener("click", async () => {
    const base = normalizeBaseUrl($("modelUrl").value);
    if (!base) return alert("Paste a model URL first.");
    try {
      $("btnStart").disabled = true;
      await stopAll();
      await loadModel(base);
      $("btnStop").disabled = false;
      log("Running.");
    } catch (e) {
      alert("Could not start model/webcam:\n\n" + e.message);
      log("Start error: " + e.message);
      $("btnStart").disabled = false;
      $("btnStop").disabled = true;
    }
  });

  $("btnStop").addEventListener("click", async () => {
    await stopAll();
    $("btnStop").disabled = true;
    $("btnStart").disabled = false;
  });

  window.addEventListener("beforeunload", async () => {
    await stopAll();
    await disconnectSerial();
  });

  // Initial UI state
  setStatus("Not connected", false);
  $("thresholdVal").textContent = $("threshold").value;
</script>
</body>
</html>
